# namespace geode



## Namespaces

* [detail](detail/index.md)


## Records

* [AABBTree](AABBTree.md)
* [AttributeBase](AttributeBase.md)
* [AttributeCoordinateReferenceSystem](AttributeCoordinateReferenceSystem.md)
* [AttributeLinearInterpolationImpl](AttributeLinearInterpolationImpl.md)
* [AttributeLinearInterpolation](AttributeLinearInterpolation.md)
* [AttributeManager](AttributeManager.md)
* [AttributeProperties](AttributeProperties.md)
* [BRepBuilder](BRepBuilder.md)
* [BRepComponentMeshEdges](BRepComponentMeshEdges.md)
* [BRepComponentMeshPolygons](BRepComponentMeshPolygons.md)
* [BRepInput](BRepInput.md)
* [BRepMeshesElementMapping](BRepMeshesElementMapping.md)
* [BRepMeshesVertexMapping](BRepMeshesVertexMapping.md)
* [BRepOutput](BRepOutput.md)
* [BRep](BRep.md)
* [BaseRange](BaseRange.md)
* [BeginEnd](BeginEnd.md)
* [BijectiveMapping](BijectiveMapping.md)
* [BitseryExtensions](BitseryExtensions.md)
* [BlockDefinition](BlockDefinition.md)
* [BlockPolyhedraFacetVertices](BlockPolyhedraFacetVertices.md)
* [BlockPolyhedronFacet](BlockPolyhedronFacet.md)
* [Block](Block.md)
* [BlocksBuilder](BlocksBuilder.md)
* [Blocks](Blocks.md)
* [BoundaryDefinition](BoundaryDefinition.md)
* [BoundingBox](BoundingBox.md)
* [CRSTag](CRSTag.md)
* [CachedValue](CachedValue.md)
* [CellArray](CellArray.md)
* [Circle](Circle.md)
* [ComponentID](ComponentID.md)
* [ComponentMeshElement](ComponentMeshElement.md)
* [ComponentMeshVertex](ComponentMeshVertex.md)
* [ComponentTag](ComponentTag.md)
* [Component](Component.md)
* [ConsoleLoggerClient](ConsoleLoggerClient.md)
* [ConsoleProgressLoggerClient](ConsoleProgressLoggerClient.md)
* [ConstantAttribute](ConstantAttribute.md)
* [CoordinateReferenceSystemManagerBuilder](CoordinateReferenceSystemManagerBuilder.md)
* [CoordinateReferenceSystemManager](CoordinateReferenceSystemManager.md)
* [CoordinateReferenceSystemManagersBuilder](CoordinateReferenceSystemManagersBuilder.md)
* [CoordinateReferenceSystemManagers](CoordinateReferenceSystemManagers.md)
* [CoordinateReferenceSystem](CoordinateReferenceSystem.md)
* [CoordinateSystem](CoordinateSystem.md)
* [CornerDefinition](CornerDefinition.md)
* [Corner](Corner.md)
* [CornersBuilder](CornersBuilder.md)
* [Corners](Corners.md)
* [CorrectnessInfo](CorrectnessInfo.md)
* [Cylinder](Cylinder.md)
* [DecrementOperator](DecrementOperator.md)
* [DistanceToEdge](DistanceToEdge.md)
* [DistanceToTetrahedron](DistanceToTetrahedron.md)
* [DistanceToTriangle](DistanceToTriangle.md)
* [EdgeVertex](EdgeVertex.md)
* [EdgedCurveBuilder](EdgedCurveBuilder.md)
* [EdgedCurveInput](EdgedCurveInput.md)
* [EdgedCurveOutput](EdgedCurveOutput.md)
* [EdgedCurve](EdgedCurve.md)
* [EraserRange](EraserRange.md)
* [EuclideanDistanceTransform](EuclideanDistanceTransform.md)
* [Factory](Factory.md)
* [Frame](Frame.md)
* [GenericAttributeConversion](GenericAttributeConversion.md)
* [GenericCircle](GenericCircle.md)
* [GenericLine](GenericLine.md)
* [GenericMapping](GenericMapping.md)
* [GenericMeshAccessor](GenericMeshAccessor.md)
* [GenericPlane](GenericPlane.md)
* [GenericSegment](GenericSegment.md)
* [GenericSphere](GenericSphere.md)
* [GenericTetrahedron](GenericTetrahedron.md)
* [GenericTriangle](GenericTriangle.md)
* [GraphBuilder](GraphBuilder.md)
* [GraphInput](GraphInput.md)
* [GraphOutput](GraphOutput.md)
* [Graph](Graph.md)
* [GreyscaleColor](GreyscaleColor.md)
* [GridBuilder](GridBuilder.md)
* [Grid](Grid.md)
* [Growable](Growable.md)
* [HybridSolidBuilder](HybridSolidBuilder.md)
* [HybridSolidInput](HybridSolidInput.md)
* [HybridSolidOutput](HybridSolidOutput.md)
* [HybridSolid](HybridSolid.md)
* [IOFile](IOFile.md)
* [IdentifierBuilder](IdentifierBuilder.md)
* [Identifier](Identifier.md)
* [IncrementOperator](IncrementOperator.md)
* [InfiniteLine](InfiniteLine.md)
* [Input](Input.md)
* [IntersectionResult](IntersectionResult.md)
* [Library](Library.md)
* [LightRegularGrid](LightRegularGrid.md)
* [LineDefinition](LineDefinition.md)
* [Line](Line.md)
* [LinesBuilder](LinesBuilder.md)
* [Lines](Lines.md)
* [LoggerClient](LoggerClient.md)
* [LoggerManager](LoggerManager.md)
* [Logger](Logger.md)
* [MappingBase](MappingBase.md)
* [MeshBuilderFactoryKey](MeshBuilderFactoryKey.md)
* [MeshBuilderFactory](MeshBuilderFactory.md)
* [MeshEdge](MeshEdge.md)
* [MeshElement](MeshElement.md)
* [MeshFactory](MeshFactory.md)
* [MeshImplTag](MeshImplTag.md)
* [MeshPolygon](MeshPolygon.md)
* [MeshTypeTag](MeshTypeTag.md)
* [MeshVertex](MeshVertex.md)
* [ModelBoundariesBuilder](ModelBoundariesBuilder.md)
* [ModelBoundaries](ModelBoundaries.md)
* [ModelBoundary](ModelBoundary.md)
* [ModelComponentMeshEdges](ModelComponentMeshEdges.md)
* [ModelConcatener](ModelConcatener.md)
* [ModelMapping](ModelMapping.md)
* [ModelMeshesAABBTree](ModelMeshesAABBTree.md)
* [ModelMeshesElementMapping](ModelMeshesElementMapping.md)
* [ModelMeshesVertexMapping](ModelMeshesVertexMapping.md)
* [MultipleValueStorage](MultipleValueStorage.md)
* [NNSearch](NNSearch.md)
* [NamedType](NamedType.md)
* [OneValueStorage](OneValueStorage.md)
* [OpenGeodeBRepInput](OpenGeodeBRepInput.md)
* [OpenGeodeBRepOutput](OpenGeodeBRepOutput.md)
* [OpenGeodeBasicLibrary](OpenGeodeBasicLibrary.md)
* [OpenGeodeEdgedCurveBuilder](OpenGeodeEdgedCurveBuilder.md)
* [OpenGeodeEdgedCurveInput](OpenGeodeEdgedCurveInput.md)
* [OpenGeodeEdgedCurveOutput](OpenGeodeEdgedCurveOutput.md)
* [OpenGeodeEdgedCurve](OpenGeodeEdgedCurve.md)
* [OpenGeodeException](OpenGeodeException.md)
* [OpenGeodeGeometryLibrary](OpenGeodeGeometryLibrary.md)
* [OpenGeodeGraphBuilder](OpenGeodeGraphBuilder.md)
* [OpenGeodeGraphInput](OpenGeodeGraphInput.md)
* [OpenGeodeGraphOutput](OpenGeodeGraphOutput.md)
* [OpenGeodeGraph](OpenGeodeGraph.md)
* [OpenGeodeHybridSolidBuilder](OpenGeodeHybridSolidBuilder.md)
* [OpenGeodeHybridSolidInput](OpenGeodeHybridSolidInput.md)
* [OpenGeodeHybridSolidOutput](OpenGeodeHybridSolidOutput.md)
* [OpenGeodeHybridSolid](OpenGeodeHybridSolid.md)
* [OpenGeodeImageLibrary](OpenGeodeImageLibrary.md)
* [OpenGeodeMeshLibrary](OpenGeodeMeshLibrary.md)
* [OpenGeodeModelLibrary](OpenGeodeModelLibrary.md)
* [OpenGeodePointSetBuilder](OpenGeodePointSetBuilder.md)
* [OpenGeodePointSetInput](OpenGeodePointSetInput.md)
* [OpenGeodePointSetOutput](OpenGeodePointSetOutput.md)
* [OpenGeodePointSet](OpenGeodePointSet.md)
* [OpenGeodePolygonalSurfaceBuilder](OpenGeodePolygonalSurfaceBuilder.md)
* [OpenGeodePolygonalSurfaceInput](OpenGeodePolygonalSurfaceInput.md)
* [OpenGeodePolygonalSurfaceOutput](OpenGeodePolygonalSurfaceOutput.md)
* [OpenGeodePolygonalSurface](OpenGeodePolygonalSurface.md)
* [OpenGeodePolyhedralSolidBuilder](OpenGeodePolyhedralSolidBuilder.md)
* [OpenGeodePolyhedralSolidInput](OpenGeodePolyhedralSolidInput.md)
* [OpenGeodePolyhedralSolidOutput](OpenGeodePolyhedralSolidOutput.md)
* [OpenGeodePolyhedralSolid](OpenGeodePolyhedralSolid.md)
* [OpenGeodeRasterImageInput](OpenGeodeRasterImageInput.md)
* [OpenGeodeRasterImageOutput](OpenGeodeRasterImageOutput.md)
* [OpenGeodeRegularGridBuilder](OpenGeodeRegularGridBuilder.md)
* [OpenGeodeRegularGridInput](OpenGeodeRegularGridInput.md)
* [OpenGeodeRegularGridOutput](OpenGeodeRegularGridOutput.md)
* [OpenGeodeRegularGrid](OpenGeodeRegularGrid.md)
* [OpenGeodeSectionInput](OpenGeodeSectionInput.md)
* [OpenGeodeSectionOutput](OpenGeodeSectionOutput.md)
* [OpenGeodeTetrahedralSolidBuilder](OpenGeodeTetrahedralSolidBuilder.md)
* [OpenGeodeTetrahedralSolidInput](OpenGeodeTetrahedralSolidInput.md)
* [OpenGeodeTetrahedralSolidOutput](OpenGeodeTetrahedralSolidOutput.md)
* [OpenGeodeTetrahedralSolid](OpenGeodeTetrahedralSolid.md)
* [OpenGeodeTriangulatedSurfaceBuilder](OpenGeodeTriangulatedSurfaceBuilder.md)
* [OpenGeodeTriangulatedSurfaceInput](OpenGeodeTriangulatedSurfaceInput.md)
* [OpenGeodeTriangulatedSurfaceOutput](OpenGeodeTriangulatedSurfaceOutput.md)
* [OpenGeodeTriangulatedSurface](OpenGeodeTriangulatedSurface.md)
* [OpenGeodeVertexSetBuilder](OpenGeodeVertexSetBuilder.md)
* [OpenGeodeVertexSetInput](OpenGeodeVertexSetInput.md)
* [OpenGeodeVertexSetOutput](OpenGeodeVertexSetOutput.md)
* [OpenGeodeVertexSet](OpenGeodeVertexSet.md)
* [Output](Output.md)
* [OwnerCircle](OwnerCircle.md)
* [OwnerInfiniteLine](OwnerInfiniteLine.md)
* [OwnerPlane](OwnerPlane.md)
* [OwnerRay](OwnerRay.md)
* [OwnerSegment](OwnerSegment.md)
* [OwnerSphere](OwnerSphere.md)
* [OwnerTetrahedron](OwnerTetrahedron.md)
* [OwnerTriangle](OwnerTriangle.md)
* [PImpl](PImpl.md)
* [PassKey](PassKey.md)
* [Plane](Plane.md)
* [PointSetBuilder](PointSetBuilder.md)
* [PointSetInput](PointSetInput.md)
* [PointSetOutput](PointSetOutput.md)
* [PointSet](PointSet.md)
* [Point](Point.md)
* [PolygonEdge](PolygonEdge.md)
* [PolygonVertex](PolygonVertex.md)
* [PolygonalSurfaceBuilder](PolygonalSurfaceBuilder.md)
* [PolygonalSurfaceInput](PolygonalSurfaceInput.md)
* [PolygonalSurfaceOutput](PolygonalSurfaceOutput.md)
* [PolygonalSurface](PolygonalSurface.md)
* [PolyhedralSolidBuilder](PolyhedralSolidBuilder.md)
* [PolyhedralSolidInput](PolyhedralSolidInput.md)
* [PolyhedralSolidOutput](PolyhedralSolidOutput.md)
* [PolyhedralSolid](PolyhedralSolid.md)
* [PolyhedronFacetEdge](PolyhedronFacetEdge.md)
* [PolyhedronFacetVertex](PolyhedronFacetVertex.md)
* [PolyhedronFacet](PolyhedronFacet.md)
* [PolyhedronVertex](PolyhedronVertex.md)
* [ProgressLoggerClient](ProgressLoggerClient.md)
* [ProgressLoggerManager](ProgressLoggerManager.md)
* [ProgressLogger](ProgressLogger.md)
* [RGBColor](RGBColor.md)
* [RasterImageInput](RasterImageInput.md)
* [RasterImageOutput](RasterImageOutput.md)
* [RasterImage](RasterImage.md)
* [RayTracing3D](RayTracing3D.md)
* [Ray](Ray.md)
* [ReadOnlyAttribute](ReadOnlyAttribute.md)
* [RegularGridBuilder](RegularGridBuilder.md)
* [RegularGridInput](RegularGridInput.md)
* [RegularGridOutput](RegularGridOutput.md)
* [RegularGridPointFunction](RegularGridPointFunction.md)
* [RegularGridScalarFunction](RegularGridScalarFunction.md)
* [RegularGrid](RegularGrid.md)
* [RelationshipsBuilder](RelationshipsBuilder.md)
* [Relationships](Relationships.md)
* [SectionBuilder](SectionBuilder.md)
* [SectionComponentMeshEdges](SectionComponentMeshEdges.md)
* [SectionExtruderOptions](SectionExtruderOptions.md)
* [SectionInput](SectionInput.md)
* [SectionMeshesElementMapping](SectionMeshesElementMapping.md)
* [SectionMeshesVertexMapping](SectionMeshesVertexMapping.md)
* [SectionOutput](SectionOutput.md)
* [Section](Section.md)
* [Segment](Segment.md)
* [SidedSurface](SidedSurface.md)
* [SimplicialBRepCreator](SimplicialBRepCreator.md)
* [SimplicialSectionCreator](SimplicialSectionCreator.md)
* [Singleton](Singleton.md)
* [SolidEdgesBuilder](SolidEdgesBuilder.md)
* [SolidEdges](SolidEdges.md)
* [SolidFacetsBuilder](SolidFacetsBuilder.md)
* [SolidFacets](SolidFacets.md)
* [SolidMeshBuilder](SolidMeshBuilder.md)
* [SolidMesh](SolidMesh.md)
* [SortedSurfaces](SortedSurfaces.md)
* [SparseAttribute](SparseAttribute.md)
* [Sphere](Sphere.md)
* [SquareMatrix](SquareMatrix.md)
* [SurfaceDefinition](SurfaceDefinition.md)
* [SurfaceEdgesBuilder](SurfaceEdgesBuilder.md)
* [SurfaceEdges](SurfaceEdges.md)
* [SurfaceMeshBuilder](SurfaceMeshBuilder.md)
* [SurfaceMesh](SurfaceMesh.md)
* [SurfacePolygonEdge](SurfacePolygonEdge.md)
* [SurfacePolygonsEdgeVertices](SurfacePolygonsEdgeVertices.md)
* [Surface](Surface.md)
* [SurfacesBuilder](SurfacesBuilder.md)
* [Surfaces](Surfaces.md)
* [TIndices](TIndices.md)
* [TRange](TRange.md)
* [TReverseRange](TReverseRange.md)
* [TetrahedralSolidBuilder](TetrahedralSolidBuilder.md)
* [TetrahedralSolidInput](TetrahedralSolidInput.md)
* [TetrahedralSolidOutput](TetrahedralSolidOutput.md)
* [TetrahedralSolidPointFunction](TetrahedralSolidPointFunction.md)
* [TetrahedralSolidScalarFunction](TetrahedralSolidScalarFunction.md)
* [TetrahedralSolid](TetrahedralSolid.md)
* [Tetrahedron](Tetrahedron.md)
* [TextureManager](TextureManager.md)
* [TextureStorage](TextureStorage.md)
* [Texture](Texture.md)
* [Timer](Timer.md)
* [TopologyBuilder](TopologyBuilder.md)
* [Topology](Topology.md)
* [Triangle](Triangle.md)
* [TriangulatedSurfaceBuilder](TriangulatedSurfaceBuilder.md)
* [TriangulatedSurfaceInput](TriangulatedSurfaceInput.md)
* [TriangulatedSurfaceOutput](TriangulatedSurfaceOutput.md)
* [TriangulatedSurfacePointFunction](TriangulatedSurfacePointFunction.md)
* [TriangulatedSurfaceScalarFunction](TriangulatedSurfaceScalarFunction.md)
* [TriangulatedSurface](TriangulatedSurface.md)
* [UnzipFile](UnzipFile.md)
* [VariableAttribute](VariableAttribute.md)
* [Vector](Vector.md)
* [VertexIdentifierBuilder](VertexIdentifierBuilder.md)
* [VertexIdentifier](VertexIdentifier.md)
* [VertexSetBuilder](VertexSetBuilder.md)
* [VertexSetInput](VertexSetInput.md)
* [VertexSetOutput](VertexSetOutput.md)
* [VertexSet](VertexSet.md)
* [ZipFile](ZipFile.md)
* [uuid](uuid.md)


## Functions

### geode_assertion_failed

```cpp
void geode_assertion_failed(string_view condition, string_view message, string_view file, int line)
```


### geode_lippincott

```cpp
int geode_lippincott()
```


 Try to catch several exception types. Always return 1.

### operator""_uc

```cpp
unsigned char operator""_uc(unsigned long long arg)
```


### to_string

```cpp
basic_string to_string(string_view view)
```


### to_array

```cpp
std::array<T, sizeof...(Args)> to_array(Args &&... args)
```


### register_basic_serialize_pcontext

```cpp
void register_basic_serialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to serialize the objects in the basic library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### register_basic_deserialize_pcontext

```cpp
void register_basic_deserialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to deserialize the objects in the basic library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### delete_vector_elements

```cpp
index_t delete_vector_elements(const std::vector<_Bool> & to_delete, std::vector<T> & values)
```


 Delete some elements from a given vector.

**T** Type of the vector elements.

**to_delete** [in] Vector of the same size than values. If to_delete[i] is true the i-th element is deleted, else the element is kept.

**values** [in] Vector in which perform deletions.

**pre** T should have default constructor (needed for call resize method on vector).

**return** The number of deleted elements

### extract_vector_elements

```cpp
std::vector<T> extract_vector_elements(const std::vector<_Bool> & to_keep, const std::vector<T> & in_values)
```


 Create a new vector containing only some elements from a given vector.

**T** Type of the vector elements.

**to_keep** [in] Vector of the same size than in_values. If to_keep[i] is true the i-th element is kept.

**in_values** [in] Vector in which perform deletions.

**return** A vector containing only kept elements of in_values

### sort_unique

```cpp
void sort_unique(Container & in)
```


 Modify the container by removing every duplicated values inside

**Container** Type of container.

**in** [in] container in which perform the search.

### permute

```cpp
void permute(Container & data, Span permutation)
```


### old2new_permutation

```cpp
vector old2new_permutation(Span permutation)
```


### register_geometry_serialize_pcontext

```cpp
void register_geometry_serialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to serialize the objects in the geometry library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### register_geometry_deserialize_pcontext

```cpp
void register_geometry_deserialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to deserialize the objects in the geometry library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### save_graph

```cpp
void save_graph(const Graph & graph, string_view filename)
```


 API function for saving a Graph. The adequate saver is called depending on the given filename extension.

**graph** [in] Graph to save.

**filename** [in] Path to the file where save the Graph.

### filename_with_extension

```cpp
basic_string filename_with_extension(string_view path)
```


### filename_without_extension

```cpp
basic_string filename_without_extension(string_view path)
```


### filepath_without_extension

```cpp
basic_string filepath_without_extension(string_view path)
```


### filepath_without_filename

```cpp
basic_string filepath_without_filename(string_view path)
```


### extension_from_filename

```cpp
string_view extension_from_filename(string_view filename)
```


### load_section

```cpp
Section load_section(string_view filename)
```


 API function for loading a Section. The adequate loader is called depending on the filename extension.

**filename** [in] Path to the file to load.

**return** Loaded Section.

### check_section_missing_files

```cpp
MissingFiles check_section_missing_files(string_view filename)
```


### load_polyhedral_solid

```cpp
std::unique_ptr<PolyhedralSolid<dimension> > load_polyhedral_solid(const MeshImpl & impl, string_view filename)
```


 API function for loading an PolyhedralSolid. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_polyhedral_solid

```cpp
std::unique_ptr<PolyhedralSolid<dimension> > load_polyhedral_solid(string_view filename)
```


 API function for loading an PolyhedralSolid. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_polyhedral_solid_missing_files

```cpp
typename PolyhedralSolidInput<dimension>::MissingFiles check_polyhedral_solid_missing_files(string_view filename)
```


### radial_sort

```cpp
FixedArray radial_sort(const Segment3D & segment, Span points)
```


### point_side_to_segment

```cpp
Side point_side_to_segment(const Point2D & point, const Segment2D & segment)
```


 Return the point side to a segment.

### point_side_to_line

```cpp
Side point_side_to_line(const Point2D & point, const InfiniteLine2D & line)
```


 Return the point side to a line.

### point_side_to_plane

```cpp
Side point_side_to_plane(const Point3D & point, const Plane & plane)
```


 Return the point side to a plane.

### point_side_to_triangle

```cpp
Side point_side_to_triangle(const Point3D & point, const Triangle3D & triangle)
```


 Return the point side to a 3D triangle.

### point_segment_position

```cpp
Position point_segment_position(const Point<dimension> & point, const Segment<dimension> & segment)
```


 Return the position of a point on a segment: inside, outside or on segment vertex.

### point_triangle_position

```cpp
Position point_triangle_position(const Point<dimension> & point, const Triangle<dimension> & triangle)
```

 Return the position of a point in a triangle: inside, outside, on a triangle vertex or an edge.

### point_tetrahedron_position

```cpp
Position point_tetrahedron_position(const Point3D & point, const Tetrahedron & tetra)
```


 Return the position of a point in a tetrahedron: inside, outside, on a tetra vertex, an edge or a facet.

### point_segment_projection

```cpp
Point<dimension> point_segment_projection(const Point<dimension> & point, const Segment<dimension> & segment)
```


 Return the projection of a point on a segment

**point** [in] the point to project

**segment** [in] the segment

### point_line_projection

```cpp
Point<dimension> point_line_projection(const Point<dimension> & point, const InfiniteLine<dimension> & line)
```


 Return the projection of a point on a line

**point** [in] the point to project

**line** [in] the line

### point_triangle_projection

```cpp
Point<dimension> point_triangle_projection(const Point<dimension> & point, const Triangle<dimension> & triangle)
```


 Return the projection of a point on a triangle

**point** [in] the point to project

**triangle** [in] the triangle

### point_plane_projection

```cpp
Point point_plane_projection(const Point3D & point, const Plane & plane)
```


 Return the projection of a point on a plane

**point** [in] the point to project

**plane** [in] the plane

### save_section

```cpp
void save_section(const Section & section, string_view filename)
```


 API function for saving a Section. The adequate saver is called depending on the given filename extension.

**section** [in] Section to save.

**filename** [in] Path to the file where save the section.

### point_point_distance

```cpp
double point_point_distance(const Point<dimension> & point0, const Point<dimension> & point1)
```


 Compute the Euclidean distance between a two points

### point_segment_distance

```cpp
double point_segment_distance(const Point<dimension> & point, const Segment<dimension> & segment)
```


 Compute the smallest distance between a point and a segment

### segment_segment_distance

```cpp
std::tuple<double, Point<dimension>, Point<dimension> > segment_segment_distance(const Segment<dimension> & segment0, const Segment<dimension> & segment1)
```


 Compute the smallest distance between two segments

**return** a tuple containing: - the smallest distance. - the closest point on the first segment. - the closest point on the second segment.

### segment_line_distance

```cpp
std::tuple<double, Point<dimension>, Point<dimension> > segment_line_distance(const Segment<dimension> & segment, const InfiniteLine<dimension> & line)
```


### point_line_distance

```cpp
double point_line_distance(const Point<dimension> & point, const InfiniteLine<dimension> & line)
```


 Compute the smallest distance between a point and an infinite line

### point_line_signed_distance

```cpp
double point_line_signed_distance(const Point2D & point, const InfiniteLine2D & line)
```


 Compute the smallest signed distance between a point and an infinite line in 2D

### point_triangle_distance

```cpp
std::tuple<double, Point<dimension> > point_triangle_distance(const Point<dimension> & point, const Triangle<dimension> & triangle)
```

 Compute the smallest distance between a point and a triangle

**return** a tuple containing: - the smallest distance. - the closest point on the triangle.

### point_triangle_signed_distance

```cpp
tuple point_triangle_signed_distance(const Point3D & point, const Triangle3D & triangle)
```


 Compute the signed distance between a point and a triangle

**return** a tuple containing: - the smallest distance. - the closest point on the triangle.

**details** the sign is given by the triangle normal (positive if in the same plane).

### line_triangle_distance

```cpp
std::tuple<double, Point3D, Point3D> line_triangle_distance(const InfiniteLine3D & line, const Triangle3D & triangle)
```


 Compute the smallest distance between an infinite line and a triangle

**return** a tuple containing: - the smallest distance. - the closest point on the line. - the closest point on the triangle.

### segment_triangle_distance

```cpp
std::tuple<double, Point3D, Point3D> segment_triangle_distance(const Segment3D & segment, const Triangle3D & triangle)
```


 Compute the smallest distance between an segment and a triangle

**return** a tuple containing: - the smallest distance. - the closest point on the segment. - the closest point on the triangle.

### point_tetrahedron_distance

```cpp
tuple point_tetrahedron_distance(const Point3D & point, const Tetrahedron & tetra)
```


 Compute the distance between a point and a tetrahedron

**return** a tuple containing: - the smallest distance. - the nearest point on the tetrahedron.

### point_plane_distance

```cpp
tuple point_plane_distance(const Point3D & point, const Plane & plane)
```


 Compute the distance between a point and a plane

**return** a tuple containing: - the smallest distance. - the nearest point on the plane.

### point_plane_signed_distance

```cpp
tuple point_plane_signed_distance(const Point3D & point, const Plane & plane)
```


 Compute the signed distance between a point and a plane

**return** a tuple containing: - the signed distance (sign is given by the plane normal direction). - the nearest point on the plane.

### point_sphere_distance

```cpp
std::tuple<double, Point<dimension> > point_sphere_distance(const Point<dimension> & point, const Sphere<dimension> & sphere)
```


 Compute the smallest distance between a point and a sphere

**return** a tuple containing: - the smallest distance. - the closest point on the sphere.

### point_sphere_signed_distance

```cpp
std::tuple<double, Point<dimension> > point_sphere_signed_distance(const Point<dimension> & point, const Sphere<dimension> & sphere)
```


 Compute the smallest signed distance between a point and a sphere

**return** a tuple containing: - the smallest signed distance. - the closest point on the sphere.

**details** the sign is positive outside the sphere, negative inside.

### point_ball_distance

```cpp
std::tuple<double, Point<dimension> > point_ball_distance(const Point<dimension> & point, const Ball<dimension> & sphere)
```

 Compute the smallest distance between a point and a ball

**return** a tuple containing: - the smallest distance. - the closest point on the ball.

**details** Result is always positive or null. If point is inside the ball, the returned distance is 0.

### point_circle_distance

```cpp
tuple point_circle_distance(const Point3D & point, const Circle & circle)
```


 Compute the smallest distance between a point and a circle

**return** a tuple containing: - the smallest distance. - the closest point on the circle.

### point_circle_signed_distance

```cpp
tuple point_circle_signed_distance(const Point3D & point, const Circle & circle)
```


 Compute the smallest signed distance between a point and a circle

**return** a tuple containing: - the smallest signed distance. - the closest point on the circle.

**details** the sign is positive outside the circle, negative inside.

### point_disk_distance

```cpp
tuple point_disk_distance(const Point3D & point, const Disk & disk)
```


 Compute the smallest distance between a point and a disk

**return** a tuple containing: - the smallest distance. - the closest point on the disk.

**details** Result is always positive or null. If point is inside the disk, the returned distance is 0.

### save_brep

```cpp
void save_brep(const BRep & brep, string_view filename)
```


 API function for saving a BoundaryRepresentation. The adequate saver is called depending on the given filename extension.

**brep** [in] BRep to save.

**filename** [in] Path to the file where save the brep.

### perpendicular

```cpp
Vector perpendicular(const Vector2D & v)
```


 Return a 2D vector perpendicular to the given one

### dot_perpendicular

```cpp
double dot_perpendicular(const Vector2D & v0, const Vector2D & v1)
```


 Compute the dot product between a 2D vector **p**  and another 2D vector perpendicular to **p** 

### load_tetrahedral_solid

```cpp
std::unique_ptr<TetrahedralSolid<dimension> > load_tetrahedral_solid(const MeshImpl & impl, string_view filename)
```


 API function for loading an TetrahedralSolid. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_tetrahedral_solid

```cpp
std::unique_ptr<TetrahedralSolid<dimension> > load_tetrahedral_solid(string_view filename)
```


 API function for loading an TetrahedralSolid. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_tetrahedral_solid_missing_files

```cpp
typename TetrahedralSolidInput<dimension>::MissingFiles check_tetrahedral_solid_missing_files(string_view filename)
```


### load_triangulated_surface

```cpp
std::unique_ptr<TriangulatedSurface<dimension> > load_triangulated_surface(const MeshImpl & impl, string_view filename)
```


 API function for loading an TriangulatedSurface. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_triangulated_surface

```cpp
std::unique_ptr<TriangulatedSurface<dimension> > load_triangulated_surface(string_view filename)
```


 API function for loading an TriangulatedSurface. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_triangulated_surface_missing_files

```cpp
typename TriangulatedSurfaceInput<dimension>::MissingFiles check_triangulated_surface_missing_files(string_view filename)
```


### triangle_area

```cpp
double triangle_area(const Triangle<dimension> & triangle)
```


 Compute the (positive) area of a triangle

**triangle** [in] Triangle to compute area

### triangle_signed_area

```cpp
double triangle_signed_area(const Triangle2D & triangle)
```


 Compute the signed area of a triangle

**triangle** [in] Triangle to compute area returned area is positive if the triangle vertices are ordered counter-clockwise, negative if clockwise.

### triangle_signed_area

```cpp
double triangle_signed_area(const Triangle3D & triangle, const Vector3D & direction)
```


 Compute the signed area of a 3D triangle

**triangle** [in] Triangle to compute area

**direction** [in] Direction used to determined the sign of returned area: positive if the triangle normal is in the same direction than direction, negative if the triangle normal is in the opposition direction.

### tetrahedron_signed_volume

```cpp
double tetrahedron_signed_volume(const Tetrahedron & tetra)
```


 Compute the signed volume of a tetrahedron

### tetrahedron_volume

```cpp
double tetrahedron_volume(const Tetrahedron & tetra)
```


 Compute the (positive) volume of a tetrahedron

### register_mesh_serialize_pcontext

```cpp
void register_mesh_serialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to serialize the objects in the mesh library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### register_mesh_deserialize_pcontext

```cpp
void register_mesh_deserialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to deserialize the objects in the mesh library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### save_triangulated_surface

```cpp
void save_triangulated_surface(const TriangulatedSurface<dimension> & triangulated_surface, string_view filename)
```


 API function for saving a TriangulatedSurface. The adequate saver is called depending on the given filename extension.

**triangulated_surface** [in] TriangulatedSurface to save.

**filename** [in] Path to the file where save the TriangulatedSurface.

### polyhedron_unique_vertices

```cpp
InlinedVector polyhedron_unique_vertices(const BRep & model, const Block3D & block, index_t polyhedron_id)
```


### component_mesh_polyhedra

```cpp
vector component_mesh_polyhedra(const BRep & brep, const PolyhedronVertices & polyhedron_unique_vertices)
```


### component_mesh_vertex_generic

```cpp
ComponentMeshVertexGeneric<dimension> component_mesh_vertex_generic(absl::Span<const absl::Span<const ComponentMeshVertex> > unique_vertices)
```


### component_mesh_vertex_generic

```cpp
ComponentMeshVertexGeneric<dimension> component_mesh_vertex_generic(absl::Span<const absl::Span<const ComponentMeshVertex> > unique_vertices, const ComponentType & type)
```


### component_mesh_vertex_pairs

```cpp
ComponentMeshVertexPairs component_mesh_vertex_pairs(absl::Span<const ComponentMeshVertex> unique_vertices0, absl::Span<const ComponentMeshVertex> unique_vertices1)
```


### component_mesh_vertex_pairs

```cpp
ComponentMeshVertexPairs component_mesh_vertex_pairs(absl::Span<const ComponentMeshVertex> unique_vertices0, absl::Span<const ComponentMeshVertex> unique_vertices1, const ComponentType & type)
```


### component_mesh_vertex_triplets

```cpp
ComponentMeshVertexTriplets component_mesh_vertex_triplets(absl::Span<const ComponentMeshVertex> unique_vertices0, absl::Span<const ComponentMeshVertex> unique_vertices1, absl::Span<const ComponentMeshVertex> unique_vertices2)
```


### component_mesh_vertex_triplets

```cpp
ComponentMeshVertexTriplets component_mesh_vertex_triplets(absl::Span<const ComponentMeshVertex> unique_vertices0, absl::Span<const ComponentMeshVertex> unique_vertices1, absl::Span<const ComponentMeshVertex> unique_vertices2, const ComponentType & type)
```


### component_mesh_vertex_tuple

```cpp
ComponentMeshVertexGeneric<dimension> component_mesh_vertex_tuple(UniqueVertices... unique_vertices)
```


### component_mesh_vertex_tuple

```cpp
ComponentMeshVertexGeneric<dimension> component_mesh_vertex_tuple(UniqueVertices... unique_vertices, const ComponentType & type)
```


### convert_solid_mesh_into_tetrahedral_solid

```cpp
absl::optional<std::unique_ptr<TetrahedralSolid3D> > convert_solid_mesh_into_tetrahedral_solid(const SolidMesh3D & solid)
```


### convert_grid_into_tetrahedral_solid

```cpp
std::unique_ptr<TetrahedralSolid3D> convert_grid_into_tetrahedral_solid(const Grid3D & grid)
```


### convert_solid_mesh_into_hybrid_solid

```cpp
absl::optional<std::unique_ptr<HybridSolid3D> > convert_solid_mesh_into_hybrid_solid(const SolidMesh3D & solid)
```


### merge_solid_meshes

```cpp
std::unique_ptr<SolidMesh3D> merge_solid_meshes(absl::Span<const std::reference_wrapper<const SolidMesh3D> > solids)
```


### brep_coordinate_reference_systems

```cpp
FixedArray brep_coordinate_reference_systems(const BRep & brep)
```


### section_coordinate_reference_systems

```cpp
FixedArray section_coordinate_reference_systems(const Section & section)
```


### register_image_serialize_pcontext

```cpp
void register_image_serialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to serialize the objects in the image library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### register_image_deserialize_pcontext

```cpp
void register_image_deserialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to deserialize the objects in the image library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### convert_surface_mesh_into_polygonal_surface

```cpp
std::unique_ptr<PolygonalSurface<dimension> > convert_surface_mesh_into_polygonal_surface(const SurfaceMesh<dimension> & surface)
```

### convert_surface_mesh_into_triangulated_surface

```cpp
absl::optional<std::unique_ptr<TriangulatedSurface<dimension> > > convert_surface_mesh_into_triangulated_surface(const SurfaceMesh<dimension> & surface)
```

### convert_grid_into_triangulated_surface

```cpp
std::unique_ptr<TriangulatedSurface2D> convert_grid_into_triangulated_surface(const Grid2D & grid)
```


### triangulate_surface_mesh

```cpp
void triangulate_surface_mesh(SurfaceMesh<dimension> & surface)
```


### triangulate_surface_mesh

```cpp
void triangulate_surface_mesh(const SurfaceMesh<dimension> & surface, SurfaceMeshBuilder<dimension> & builder)
```


### convert_surface_mesh2d_into_3d

```cpp
std::unique_ptr<SurfaceMesh3D> convert_surface_mesh2d_into_3d(const SurfaceMesh2D & surface2d, index_t axis_to_add, double axis_coordinate)
```


### convert_surface_mesh3d_into_2d

```cpp
std::unique_ptr<SurfaceMesh2D> convert_surface_mesh3d_into_2d(const SurfaceMesh3D & surface3d, index_t axis_to_remove)
```


### convert_polygonal_surface2d_into_3d

```cpp
std::unique_ptr<PolygonalSurface3D> convert_polygonal_surface2d_into_3d(const PolygonalSurface2D & surface2d, index_t axis_to_add, double axis_coordinate)
```


### convert_polygonal_surface3d_into_2d

```cpp
std::unique_ptr<PolygonalSurface2D> convert_polygonal_surface3d_into_2d(const PolygonalSurface3D & surface3d, index_t axis_to_remove)
```


### convert_triangulated_surface2d_into_3d

```cpp
std::unique_ptr<TriangulatedSurface3D> convert_triangulated_surface2d_into_3d(const TriangulatedSurface2D & surface2d, index_t axis_to_add, double axis_coordinate)
```


### convert_triangulated_surface3d_into_2d

```cpp
std::unique_ptr<TriangulatedSurface2D> convert_triangulated_surface3d_into_2d(const TriangulatedSurface3D & surface3d, index_t axis_to_remove)
```


### merge_surface_meshes

```cpp
std::unique_ptr<SurfaceMesh<dimension> > merge_surface_meshes(absl::Span<const std::reference_wrapper<const SurfaceMesh<dimension> > > surfaces)
```

### convert_surface_mesh_into_polygonal_surface

```cpp
int convert_surface_mesh_into_polygonal_surface(const SurfaceMesh<dimension> & surface)
```


### convert_surface_mesh_into_triangulated_surface

```cpp
int convert_surface_mesh_into_triangulated_surface(const SurfaceMesh<dimension> & surface)
```


### merge_surface_meshes

```cpp
int merge_surface_meshes(absl::Span<const std::reference_wrapper<const SurfaceMesh<dimension> > > surfaces)
```


### create_aabb_tree

```cpp
AABBTree<dimension> create_aabb_tree(const SurfaceMesh<dimension> & mesh)
```


### register_geode_builder

```cpp
void register_geode_builder()
```


### load_point_set

```cpp
std::unique_ptr<PointSet<dimension> > load_point_set(const MeshImpl & impl, string_view filename)
```


 API function for loading an PointSet. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_point_set

```cpp
std::unique_ptr<PointSet<dimension> > load_point_set(string_view filename)
```


 API function for loading an PointSet. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_point_set_missing_files

```cpp
typename PointSetInput<dimension>::MissingFiles check_point_set_missing_files(string_view filename)
```


### load_graph

```cpp
unique_ptr load_graph(const MeshImpl & impl, string_view filename)
```


 API function for loading an Graph. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_graph

```cpp
unique_ptr load_graph(string_view filename)
```


 API function for loading an Graph. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_graph_missing_files

```cpp
MissingFiles check_graph_missing_files(string_view filename)
```


### register_model_serialize_pcontext

```cpp
void register_model_serialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to serialize the objects in the model library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### register_model_deserialize_pcontext

```cpp
void register_model_deserialize_pcontext(PContext & context)
```


 Register all the information needed by Bitsery to deserialize the objects in the model library.

**context** [in] The context where to register this information.

**warning** The context can be used only once per archive.

### load_brep

```cpp
BRep load_brep(string_view filename)
```


 API function for loading a BoundaryRepresentation. The adequate loader is called depending on the filename extension.

**filename** [in] Path to the file to load.

**return** Loaded BRep.

### check_brep_missing_files

```cpp
MissingFiles check_brep_missing_files(string_view filename)
```


### convert_surface_mesh

```cpp
void convert_surface_mesh(const Section & model, SectionBuilder & builder, const geode::Surface2D & surface, const geode::MeshType & mesh_type)
```


### convert_surface_mesh

```cpp
void convert_surface_mesh(const BRep & model, BRepBuilder & builder, const geode::Surface3D & surface, const geode::MeshType & mesh_type)
```


### convert_surface_meshes_into_triangulated_surfaces

```cpp
void convert_surface_meshes_into_triangulated_surfaces(BRep & brep)
```


### convert_surface_meshes_into_triangulated_surfaces

```cpp
void convert_surface_meshes_into_triangulated_surfaces(const BRep & brep, BRepBuilder & builder)
```


### convert_surface_meshes_into_triangulated_surfaces

```cpp
void convert_surface_meshes_into_triangulated_surfaces(Section & section)
```


### convert_surface_meshes_into_triangulated_surfaces

```cpp
void convert_surface_meshes_into_triangulated_surfaces(const Section & section, SectionBuilder & builder)
```


### convert_block_mesh

```cpp
void convert_block_mesh(const BRep & model, BRepBuilder & builder, const Block3D & block, const MeshType & new_mesh_type)
```


### convert_block_meshes_into_tetrahedral_solids

```cpp
void convert_block_meshes_into_tetrahedral_solids(BRep & brep)
```


### convert_block_meshes_into_tetrahedral_solids

```cpp
void convert_block_meshes_into_tetrahedral_solids(const BRep & brep, BRepBuilder & builder)
```


### triangulate_surface_meshes

```cpp
void triangulate_surface_meshes(BRep & brep)
```


### triangulate_surface_meshes

```cpp
void triangulate_surface_meshes(const BRep & brep, BRepBuilder & builder)
```


### triangulate_surface_meshes

```cpp
void triangulate_surface_meshes(Section & section)
```


### triangulate_surface_meshes

```cpp
void triangulate_surface_meshes(const Section & section, SectionBuilder & builder)
```


### tetrahedron_barycentric_coordinates

```cpp
std::array<double, 4> tetrahedron_barycentric_coordinates(const Point3D & point, const Tetrahedron & tetrahedron)
```


 Compute the barycentric coordinates of a point with regards to a tetrahedron.

**return** an array containing the parametric coordinates corresponding to the tetrahedron vertices.

**exception** throws if the tetrahedron is degenerated

### safe_tetrahedron_barycentric_coordinates

```cpp
std::array<double, 4> safe_tetrahedron_barycentric_coordinates(const Point3D & point, const Tetrahedron & tetrahedron)
```


 Compute the barycentric coordinates of a point with regards to a tetrahedron. If tetrahedron is degenerated, computation fallbacks onto its largest facet.

**return** an array containing the parametric coordinates corresponding to the tetrahedron vertices.

### triangle_barycentric_coordinates

```cpp
array triangle_barycentric_coordinates(const Point<dimension> & point, const Triangle<dimension> & triangle)
```


 Compute barycentric coordinates of a point with regards to a triangle.

**return** an array containing the parametric coordinates corresponding to the triangle vertices.

**exception** throws if the triangle is degenerated

### safe_triangle_barycentric_coordinates

```cpp
array safe_triangle_barycentric_coordinates(const Point<dimension> & point, const Triangle<dimension> & triangle)
```


 Compute barycentric coordinates of a point with regards to a triangle. If triangle is degenerated, computation fallbacks onto its longest segment.

**return** an array containing the parametric coordinates corresponding to the triangle vertices.

### segment_barycentric_coordinates

```cpp
array segment_barycentric_coordinates(const Point<dimension> & point, const Segment<dimension> & segment)
```


 Compute barycentric coordinates of a point with regards to a segment.

**return** an array containing the parametric coordinates corresponding to the segment vertices.

**exception** throws if the segment is degenerated

### safe_segment_barycentric_coordinates

```cpp
array safe_segment_barycentric_coordinates(const Point<dimension> & point, const Segment<dimension> & segment)
```


 Compute barycentric coordinates of a point with regards to a segment. If segment is degenerated, computation fallbacks onto its vertices.

**return** an array containing the parametric coordinates corresponding to the segment vertices.

### tetrahedron_volume_sign

```cpp
Side tetrahedron_volume_sign(const Tetrahedron & tetra)
```


 Return the sign of a tetrahedron volume.

### triangle_area_sign

```cpp
Side triangle_area_sign(const Triangle2D & triangle)
```


 Return the sign of a 2D triangle area.

### triangle_area_sign

```cpp
Side triangle_area_sign(const Triangle3D & triangle, local_index_t axis)
```


 Return the sign of a 3D triangle area aligned on X- Y- or Z-axis.

### point_triangle_distance

```cpp
tuple point_triangle_distance(const Point3D & point, const Triangle3D & triangle)
```


### point_triangle_distance

```cpp
std::tuple<double, Point2D> point_triangle_distance(const Point2D & point, const Triangle2D & triangle)
```


### point_ball_distance

```cpp
std::tuple<double, Point<dimension> > point_ball_distance(const Point<dimension> & point, const int & ball)
```


 Compute the smallest distance between a point and a ball

**return** a tuple containing: - the smallest distance. - the closest point on the ball.

**details** Result is always positive or null. If point is inside the ball, the returned distance is 0.

### polygon_unique_vertices

```cpp
InlinedVector polygon_unique_vertices(const BRep & model, const Surface3D & surface, index_t polygon_id)
```


### polygon_unique_vertices

```cpp
InlinedVector polygon_unique_vertices(const BRep & model, const Block3D & block, const PolyhedronFacet & facet)
```


### component_mesh_polygons

```cpp
BRepComponentMeshPolygons component_mesh_polygons(const BRep & brep, const PolygonVertices & polygon_unique_vertices)
```


### component_mesh_polygons

```cpp
BRepComponentMeshPolygons component_mesh_polygons(const BRep & brep, const Surface3D & surface, index_t polygon_id)
```


### component_mesh_polygons

```cpp
BRepComponentMeshPolygons component_mesh_polygons(const BRep & brep, const Block3D & block, const PolyhedronFacet & facet)
```


### block_mesh_polyhedra_from_surface_polygon

```cpp
PolyhedraAroundFacet block_mesh_polyhedra_from_surface_polygon(const BRep & model, const Block3D & block, const Surface3D & surface, index_t polygon_id)
```


### block_vertices_from_surface_polygon

```cpp
absl::InlinedVector<BlockPolyhedronFacet, 2> block_vertices_from_surface_polygon(const BRep & model, const Block3D & block, const Surface3D & surface, index_t polygon_id)
```


### oriented_block_vertices_from_surface_polygon

```cpp
BlockPolyhedraFacetVertices oriented_block_vertices_from_surface_polygon(const BRep & model, const Block3D & block, const Surface3D & surface, index_t polygon_id)
```


### surface_vertices_from_line_edge

```cpp
absl::InlinedVector<SurfacePolygonEdge, 2> surface_vertices_from_line_edge(const BRep & model, const Surface3D & surface, const Line3D & line, index_t edge_id)
```


### oriented_surface_vertices_from_line_edge

```cpp
SurfacePolygonsEdgeVertices oriented_surface_vertices_from_line_edge(const BRep & model, const Surface3D & surface, const Line3D & line, index_t edge_id)
```


### surface_vertices_from_line_edge

```cpp
absl::InlinedVector<SurfacePolygonEdge, 2> surface_vertices_from_line_edge(const Section & model, const Surface2D & surface, const Line2D & line, index_t edge_id)
```


### oriented_surface_vertices_from_line_edge

```cpp
SurfacePolygonsEdgeVertices oriented_surface_vertices_from_line_edge(const Section & model, const Surface2D & surface, const Line2D & line, index_t edge_id)
```


### find_intersections_with_boundaries

```cpp
flat_hash_map find_intersections_with_boundaries(const InfiniteLine3D & infinite_line, const BRep & brep, const Block3D & block)
```


### lexicographic_mapping

```cpp
vector lexicographic_mapping(absl::Span<const Point<dimension> > points)
```


### morton_mapping

```cpp
vector morton_mapping(absl::Span<const Point<dimension> > points)
```


### filter_brep_components_with_regards_to_blocks

```cpp
vector filter_brep_components_with_regards_to_blocks(BRep & brep)
```


### filter_section_components_with_regards_to_surfaces

```cpp
vector filter_section_components_with_regards_to_surfaces(Section & section)
```


### save_polyhedral_solid

```cpp
void save_polyhedral_solid(const PolyhedralSolid<dimension> & polyhedral_solid, string_view filename)
```


 API function for saving a PolyhedralSolid. The adequate saver is called depending on the given filename extension.

**polyhedral_solid** [in] PolyhedralSolid to save.

**filename** [in] Path to the file where save the PolyhedralSolid.

### save_polygonal_surface

```cpp
void save_polygonal_surface(const PolygonalSurface<dimension> & polygonal_surface, string_view filename)
```


 API function for saving a PolygonalSurface. The adequate saver is called depending on the given filename extension.        const PolygonalSurface< dimension >& polygonal_surface,

**edged_curve** [in] PolygonalSurface to save.

**filename** [in] Path to the file where save the PolygonalSurface.

### load_edged_curve

```cpp
std::unique_ptr<EdgedCurve<dimension> > load_edged_curve(const MeshImpl & impl, string_view filename)
```


 API function for loading an EdgedCurve. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_edged_curve

```cpp
std::unique_ptr<EdgedCurve<dimension> > load_edged_curve(string_view filename)
```


 API function for loading an EdgedCurve. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_edged_curve_missing_files

```cpp
typename EdgedCurveInput<dimension>::MissingFiles check_edged_curve_missing_files(string_view filename)
```


### save_edged_curve

```cpp
void save_edged_curve(const EdgedCurve<dimension> & edged_curve, string_view filename)
```


 API function for saving a EdgedCurve. The adequate saver is called depending on the given filename extension.

**edged_curve** [in] EdgedCurve to save.

**filename** [in] Path to the file where save the EdgedCurve.

### euclidean_distance_transform

```cpp
shared_ptr euclidean_distance_transform(const Grid<dimension> & grid, absl::Span<const typename Grid<dimension>::CellIndices> grid_cell_ids, string_view distance_map_name)
```


 API function for creating and computing the euclidean distance map from rasterized objects. It computes the exact euclidean distance map.



**grid** [in] Regular grid on which the euclidean distance map is computed.

**grid_cell_ids** [in] Rasterization of every objects from which the distance will be computed.

**distance_map_name** [in] Name of the attribute to store the map on the 

```cpp
*grid.*
```

**exception** OpenGeodeException if the attribute named 

**distance_map_name** cannot be accessed.

**return** the created attribute

### edge_unique_vertices

```cpp
array edge_unique_vertices(const Section & section, const Line2D & line, index_t edge)
```


### edge_unique_vertices

```cpp
array edge_unique_vertices(const Section & section, const Surface2D & surface, const PolygonEdge & edge)
```


### edge_unique_vertices

```cpp
array edge_unique_vertices(const BRep & brep, const Line3D & line, index_t edge)
```


### edge_unique_vertices

```cpp
array edge_unique_vertices(const BRep & brep, const Surface3D & surface, const PolygonEdge & edge)
```


### edge_unique_vertices

```cpp
array edge_unique_vertices(const BRep & brep, const Block3D & block, const PolyhedronFacetEdge & edge)
```


### component_mesh_edges

```cpp
SectionComponentMeshEdges component_mesh_edges(const Section & section, const std::array<index_t, 2> & edge_unique_vertices)
```


### component_mesh_edges

```cpp
SectionComponentMeshEdges component_mesh_edges(const Section & section, const Line2D & line, index_t edge)
```


### component_mesh_edges

```cpp
SectionComponentMeshEdges component_mesh_edges(const Section & section, const Surface2D & surface, const PolygonEdge & edge)
```


### component_mesh_edges

```cpp
BRepComponentMeshEdges component_mesh_edges(const BRep & brep, const std::array<index_t, 2> & edge_unique_vertices)
```


### component_mesh_edges

```cpp
BRepComponentMeshEdges component_mesh_edges(const BRep & brep, const Line3D & line, index_t edge)
```


### component_mesh_edges

```cpp
BRepComponentMeshEdges component_mesh_edges(const BRep & brep, const Surface3D & surface, const PolygonEdge & edge)
```


### component_mesh_edges

```cpp
BRepComponentMeshEdges component_mesh_edges(const BRep & brep, const Block3D & block, const PolyhedronFacetEdge & edge)
```


### convert_section_into_curve

```cpp
std::unique_ptr<EdgedCurve2D> convert_section_into_curve(const Section & section)
```


### convert_section_into_surface

```cpp
std::unique_ptr<SurfaceType> convert_section_into_surface(const Section & section)
```

### convert_section_into_curve_and_surface

```cpp
std::tuple<std::unique_ptr<EdgedCurve2D>, std::unique_ptr<SurfaceType> > convert_section_into_curve_and_surface(const Section & section)
```

### convert_brep_into_curve

```cpp
std::unique_ptr<EdgedCurve3D> convert_brep_into_curve(const BRep & brep)
```


### convert_brep_into_surface

```cpp
std::unique_ptr<SurfaceType> convert_brep_into_surface(const BRep & brep)
```

### convert_brep_into_solid

```cpp
std::unique_ptr<SolidType> convert_brep_into_solid(const BRep & brep)
```

### convert_brep_into_curve_and_surface

```cpp
std::tuple<std::unique_ptr<EdgedCurve3D>, std::unique_ptr<SurfaceType> > convert_brep_into_curve_and_surface(const BRep & brep)
```

### convert_brep_into_surface_and_solid

```cpp
std::tuple<std::unique_ptr<SurfaceType>, std::unique_ptr<SolidType> > convert_brep_into_surface_and_solid(const BRep & brep)
```

### convert_brep_into_curve_and_surface_and_solid

```cpp
std::tuple<std::unique_ptr<EdgedCurve3D>, std::unique_ptr<SurfaceType>, std::unique_ptr<SolidType> > convert_brep_into_curve_and_surface_and_solid(const BRep & brep)
```

### convert_brep_into_solid

```cpp
int convert_brep_into_solid(const BRep & brep)
```


### convert_brep_into_surface

```cpp
int convert_brep_into_surface(const BRep & brep)
```


### convert_section_into_surface

```cpp
int convert_section_into_surface(const Section & section)
```


### load_polygonal_surface

```cpp
std::unique_ptr<PolygonalSurface<dimension> > load_polygonal_surface(const MeshImpl & impl, string_view filename)
```


 API function for loading an PolygonalSurface. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_polygonal_surface

```cpp
std::unique_ptr<PolygonalSurface<dimension> > load_polygonal_surface(string_view filename)
```


 API function for loading an PolygonalSurface. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_polygonal_surface_missing_files

```cpp
typename PolygonalSurfaceInput<dimension>::MissingFiles check_polygonal_surface_missing_files(string_view filename)
```


### convert_brep_into_section

```cpp
std::tuple<Section, ModelCopyMapping> convert_brep_into_section(const BRep & brep, index_t axis_to_remove)
```


### convert_section_into_brep

```cpp
tuple convert_section_into_brep(const Section & section, index_t axis_to_add, double axis_coordinate)
```


### extrude_section_to_brep

```cpp
BRep extrude_section_to_brep(const Section & section, const SectionExtruderOptions & options)
```


### convert_edged_curve3d_into_2d

```cpp
std::unique_ptr<EdgedCurve2D> convert_edged_curve3d_into_2d(const EdgedCurve3D & curve3d, index_t axis_to_remove)
```


### convert_edged_curve2d_into_3d

```cpp
std::unique_ptr<EdgedCurve3D> convert_edged_curve2d_into_3d(const EdgedCurve2D & curve2d, index_t axis_to_add, double axis_coordinate)
```


### merge_edged_curves

```cpp
std::unique_ptr<EdgedCurve<dimension> > merge_edged_curves(absl::Span<const std::reference_wrapper<const EdgedCurve<dimension> > > curves)
```

### convert_point_set3d_into_2d

```cpp
std::unique_ptr<PointSet2D> convert_point_set3d_into_2d(const PointSet3D & point_set3d, index_t axis_to_remove)
```


### convert_point_set2d_into_3d

```cpp
std::unique_ptr<PointSet3D> convert_point_set2d_into_3d(const PointSet2D & point_set2d, index_t axis_to_add, double axis_coordinate)
```


### save_hybrid_solid

```cpp
void save_hybrid_solid(const HybridSolid<dimension> & hybrid_solid, string_view filename)
```


 API function for saving a HybridSolid. The adequate saver is called depending on the given filename extension.

**hybrid_solid** [in] HybridSolid to save.

**filename** [in] Path to the file where save the HybridSolid.

### create_brep_coordinate_system

```cpp
void create_brep_coordinate_system(const BRep & model, BRepBuilder & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### create_section_coordinate_system

```cpp
void create_section_coordinate_system(const Section & model, SectionBuilder & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### create_edged_curve_coordinate_system

```cpp
void create_edged_curve_coordinate_system(const EdgedCurve<dimension> & mesh, EdgedCurveBuilder<dimension> & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### create_point_set_coordinate_system

```cpp
void create_point_set_coordinate_system(const PointSet<dimension> & mesh, PointSetBuilder<dimension> & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### create_surface_mesh_coordinate_system

```cpp
void create_surface_mesh_coordinate_system(const SurfaceMesh<dimension> & mesh, SurfaceMeshBuilder<dimension> & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### create_solid_mesh_coordinate_system

```cpp
void create_solid_mesh_coordinate_system(const SolidMesh<dimension> & mesh, SolidMeshBuilder<dimension> & builder, string_view new_coordinate_system_name, const CoordinateSystem2D & input, const CoordinateSystem2D & output)
```


### line_plane_intersection

```cpp
IntersectionResult<Point3D> line_plane_intersection(const InfiniteLine3D & line, const Plane & plane)
```


 Compute the intersection between a plane and an infinite line

**return** an optional of the intersection.

### line_sphere_intersection

```cpp
int line_sphere_intersection(const InfiniteLine<dimension> & line, const Sphere<dimension> & sphere)
```


 Compute the intersection(s) between a sphere and an infinite line

**return** an optional of the intersection points.

### segment_sphere_intersection

```cpp
int segment_sphere_intersection(const Segment<dimension> & segment, const Sphere<dimension> & sphere)
```


 Compute the intersection(s) between a (n-1)-sphere and a segment in n-dimension space.

**return** an optional of the intersection points.

### segment_plane_intersection

```cpp
IntersectionResult<Point3D> segment_plane_intersection(const Segment3D & segment, const Plane & plane)
```


 Compute the intersection between a plane and a segment

**return** an optional of the intersection point.

**warning** if the segment is included in the plane nothing is returned

### segment_triangle_intersection

```cpp
IntersectionResult<Point3D> segment_triangle_intersection(const Segment3D & segment, const Triangle3D & triangle)
```


 Compute the intersection of a segment and a triangle

**return** an optional of the intersection point.

**warning** if the segment is included in the triangle plane nothing is returned

### line_triangle_intersection

```cpp
IntersectionResult<Point3D> line_triangle_intersection(const InfiniteLine3D & line, const Triangle3D & triangle)
```


 Compute the intersection of a line and a triangle

**return** an optional of the intersection point.

**warning** if the segment is included in the triangle plane nothing is returned

### line_line_intersection

```cpp
IntersectionResult<Point2D> line_line_intersection(const InfiniteLine2D & line0, const InfiniteLine2D & line1)
```


 Compute the intersection between two infinite lines

**return** an optional of the intersection point.

### segment_segment_intersection

```cpp
IntersectionResult<Point2D> segment_segment_intersection(const Segment2D & segment0, const Segment2D & segment1)
```


 Compute the intersection between two segments

**return** an optional of the intersection point.

### segment_line_intersection

```cpp
IntersectionResult<Point2D> segment_line_intersection(const Segment2D & segment, const InfiniteLine2D & line)
```


 Compute the intersection between a segment and an infinite line

**return** an optional of the intersection point.

### segment_cylinder_intersection

```cpp
int segment_cylinder_intersection(const Segment3D & segment, const Cylinder & cylinder)
```


 Compute the intersection between a segment and a cylinder

**return** an optional of the intersection points.

### line_cylinder_intersection

```cpp
int line_cylinder_intersection(const InfiniteLine3D & line, const Cylinder & cylinder)
```


 Compute the intersection between a line and a cylinder

**return** an optional of the intersection points.

### triangle_circle_intersection

```cpp
int triangle_circle_intersection(const Triangle3D & triangle, const Circle & circle)
```


 Compute the intersection between a triangle and a circle

**return** an optional of the intersection points.

### plane_circle_intersection

```cpp
int plane_circle_intersection(const Plane & plane, const Circle & circle)
```


 Compute the intersection between a plane and a circle

**return** an optional of the intersection points.

### plane_plane_intersection

```cpp
IntersectionResult<OwnerInfiniteLine3D> plane_plane_intersection(const Plane & plane0, const Plane & plane1)
```


 Compute the intersection between two planes

**return** an optional of the intersection line.

### segment_segment_intersection_detection

```cpp
SegmentSegmentIntersection segment_segment_intersection_detection(const Segment2D & segment0, const Segment2D & segment1)
```


 Detect if there is an intersection between two 2D segments

**return** the position of the intersection on the two segments. Returns outside-outside if there is no intersection or parallel-pallel if all points are colinear

### colinear_segment_segment_intersection_detection

```cpp
SegmentSegmentIntersection colinear_segment_segment_intersection_detection(const Segment2D & segment0, const Segment2D & segment1)
```


 Detect the configuration between two 2D colinear segments

**return** the position of the intersection on the two segments. Returns parallel-pallel if there is segment overlap

### segment_line_intersection_detection

```cpp
Position segment_line_intersection_detection(const Segment2D & segment, const InfiniteLine2D & line)
```


 Detect if there is an intersection between a line and a segment

**return** the position of the intersection on the segment. Returns outside if there is no intersection or all points are colinear

### line_triangle_intersection_detection

```cpp
Position line_triangle_intersection_detection(const InfiniteLine3D & line, const Triangle3D & triangle)
```


 Detect if there is an intersection between a line and a triangle

**return** the position of the intersection on the triangle. Returns outside if there is no intersection or the line is coplanar with the triangle

### segment_triangle_intersection_detection

```cpp
SegmentTriangleIntersection segment_triangle_intersection_detection(const Segment3D & segment, const Triangle3D & triangle)
```


 Detect if there is an intersection between a segment and a triangle

**return** the position of the intersection on the segment and on the triangle. Returns outside if there is no intersection or the segment is coplanar with the triangle

### segment_plane_intersection_detection

```cpp
Position segment_plane_intersection_detection(const Segment3D & segment, const Plane & plane)
```


 Detect if there is an intersection between a segment and a plane

**return** the position of the intersection on the segment. Returns outside if there is no intersection or the segment is coplanar with the plane

### register_geode_mesh

```cpp
void register_geode_mesh()
```


### hausdorff_distance

```cpp
double hausdorff_distance(const TriangulatedSurface3D & mesh_A, const TriangulatedSurface3D & mesh_B)
```


### rotate

```cpp
Point rotate(const Point3D & point, const Vector3D & axis, double angle)
```


 Rotate a Point3D by an angle around an axis

**point** [in] The point to rotate.

**axis** [in] Axis for the rotation (not null but not necessary normalized).

**angle** [in] Rotation angle expresses in radians.

### repair_polygon_orientations

```cpp
void repair_polygon_orientations(SurfaceMesh<dimension> & mesh)
```


### repair_polygon_orientations

```cpp
void repair_polygon_orientations(const SurfaceMesh<dimension> & mesh, SurfaceMeshBuilder<dimension> & builder)
```


### save_regular_grid

```cpp
void save_regular_grid(const RegularGrid<dimension> & regular_grid, string_view filename)
```


 API function for saving a RegularGrid. The adequate saver is called depending on the given filename extension.

**regular_grid** [in] RegularGrid to save.

**filename** [in] Path to the file where save the RegularGrid.

### point_segment_position_exact

```cpp
Position point_segment_position_exact(const Point3D & point, const Segment3D & segment)
```


### point_segment_position_exact

```cpp
Position point_segment_position_exact(const Point2D & point, const Segment2D & segment)
```


### point_triangle_position_all_zero

```cpp
Position point_triangle_position_all_zero(const Point<dimension> & point, const Triangle<dimension> & triangle)
```


### point_triangle_position_exact

```cpp
Position point_triangle_position_exact(const Point2D & point, const Triangle2D & triangle)
```


### compute_determinants

```cpp
Position compute_determinants(const Point3D & point, const Triangle3D & triangle, const Vector3D & third_vector)
```


### point_triangle_position_exact

```cpp
Position point_triangle_position_exact(const Point3D & point, const Triangle3D & triangle)
```


### point_tetrahedron_position_exact

```cpp
Position point_tetrahedron_position_exact(const Point3D & point, const Tetrahedron & tetra)
```


### point_triangle_position

```cpp
Position point_triangle_position(const Point2D & point, const Triangle2D & triangle)
```


### point_triangle_position

```cpp
Position point_triangle_position(const Point3D & point, const Triangle3D & triangle)
```


### register_geode_mesh_input

```cpp
void register_geode_mesh_input()
```


### load_hybrid_solid

```cpp
std::unique_ptr<HybridSolid<dimension> > load_hybrid_solid(const MeshImpl & impl, string_view filename)
```


 API function for loading an HybridSolid. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_hybrid_solid

```cpp
std::unique_ptr<HybridSolid<dimension> > load_hybrid_solid(string_view filename)
```


 API function for loading an HybridSolid. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_hybrid_solid_missing_files

```cpp
typename HybridSolidInput<dimension>::MissingFiles check_hybrid_solid_missing_files(string_view filename)
```


### load_regular_grid

```cpp
std::unique_ptr<RegularGrid<dimension> > load_regular_grid(const MeshImpl & impl, string_view filename)
```


 API function for loading an RegularGrid. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_regular_grid

```cpp
std::unique_ptr<RegularGrid<dimension> > load_regular_grid(string_view filename)
```


 API function for loading a RegularGrid. The adequate loader is called depending on the filename extension.

**filename** [in] Path to the file to load.

### check_regular_grid_missing_files

```cpp
typename RegularGridInput<dimension>::MissingFiles check_regular_grid_missing_files(string_view filename)
```


### load_vertex_set

```cpp
unique_ptr load_vertex_set(const MeshImpl & impl, string_view filename)
```


 API function for loading an VertexSet. The adequate loader is called depending on the filename extension.

**impl** [in] Data structure implementation.

**filename** [in] Path to the file to load.

### load_vertex_set

```cpp
unique_ptr load_vertex_set(string_view filename)
```


 API function for loading an VertexSet. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_vertex_set_missing_files

```cpp
typename class VertexSetInput::MissingFiles check_vertex_set_missing_files(string_view filename)
```


### save_point_set

```cpp
void save_point_set(const PointSet<dimension> & point_set, string_view filename)
```


 API function for saving a PointSet. The adequate saver is called depending on the given filename extension.

**point_set** [in] PointSet to save.

**filename** [in] Path to the file where save the PointSet.

### save_vertex_set

```cpp
void save_vertex_set(const VertexSet & vertex_set, string_view filename)
```


 API function for saving a VertexSet. The adequate saver is called depending on the given filename extension.

**vertex_set** [in] VertexSet to save.

**filename** [in] Path to the file where save the VertexSet.

### create_aabb_tree

```cpp
AABBTree<dimension> create_aabb_tree(const EdgedCurve<dimension> & mesh)
```


### line_sphere_intersection

```cpp
IntersectionResult<absl::InlinedVector<Point<dimension>, 2> > line_sphere_intersection(const InfiniteLine<dimension> & line, const Sphere<dimension> & sphere)
```

 Compute the intersection(s) between a sphere and an infinite line

**return** an optional of the intersection points.

### segment_sphere_intersection

```cpp
IntersectionResult<absl::InlinedVector<Point<dimension>, 2> > segment_sphere_intersection(const Segment<dimension> & segment, const Sphere<dimension> & sphere)
```

 Compute the intersection(s) between a (n-1)-sphere and a segment in n-dimension space.

**return** an optional of the intersection points.

### create_aabb_tree

```cpp
AABBTree<dimension> create_aabb_tree(const SolidMesh<dimension> & mesh)
```


### rasterize_segment

```cpp
std::vector<typename Grid<dimension>::CellIndices> rasterize_segment(const Grid<dimension> & grid, const Segment<dimension> & segment)
```

### conservative_rasterize_segment

```cpp
std::vector<typename Grid<dimension>::CellIndices> conservative_rasterize_segment(const Grid<dimension> & grid, const Segment<dimension> & segment)
```

### rasterize_triangle

```cpp
std::vector<typename Grid<dimension>::CellIndices> rasterize_triangle(const Grid<dimension> & grid, const Triangle<dimension> & triangle)
```

### rasterize_tetrahedron

```cpp
std::vector<typename Grid3D::CellIndices> rasterize_tetrahedron(const Grid3D & grid, const Tetrahedron & tetrahedron)
```


### rasterize_closed_surface

```cpp
std::vector<Grid3D::CellIndices> rasterize_closed_surface(const Grid3D & grid, const TriangulatedSurface3D & closed_surface)
```


### rasterize_segment

```cpp
int rasterize_segment(const Grid<dimension> & grid, const Segment<dimension> & segment)
```


### conservative_rasterize_segment

```cpp
int conservative_rasterize_segment(const Grid<dimension> & grid, const Segment<dimension> & segment)
```


### rasterize_triangle

```cpp
int rasterize_triangle(const Grid<dimension> & grid, const Triangle<dimension> & triangle)
```


### surface_radial_sort

```cpp
SortedSurfaces surface_radial_sort(const BRep & brep, const Line3D & line)
```


### block_volume

```cpp
double block_volume(const BRep & brep, const Block3D & block)
```


### block_bounding_box

```cpp
BoundingBox block_bounding_box(const BRep & brep, const Block3D & block)
```


### surface_area

```cpp
double surface_area(const Surface<dimension> & surface)
```


### register_geode_mesh_output

```cpp
void register_geode_mesh_output()
```


### save_tetrahedral_solid

```cpp
void save_tetrahedral_solid(const TetrahedralSolid<dimension> & tetrahedral_solid, string_view filename)
```


 API function for saving a TetrahedralSolid. The adequate saver is called depending on the given filename extension.

**tetrahedral_solid** [in] TetrahedralSolid to save.

**filename** [in] Path to the file where save the TetrahedralSolid.

### create_lines_aabb_tree

```cpp
tuple create_lines_aabb_tree(const BRep & model)
```


### create_surfaces_aabb_tree

```cpp
tuple create_surfaces_aabb_tree(const BRep & model)
```


### create_blocks_aabb_tree

```cpp
tuple create_blocks_aabb_tree(const BRep & model)
```


### create_lines_aabb_tree

```cpp
tuple create_lines_aabb_tree(const Section & model)
```


### create_surfaces_aabb_tree

```cpp
tuple create_surfaces_aabb_tree(const Section & model)
```


### create_line_meshes_aabb_trees

```cpp
ModelMeshesAABBTree create_line_meshes_aabb_trees(const BRep & model)
```


### create_surface_meshes_aabb_trees

```cpp
ModelMeshesAABBTree create_surface_meshes_aabb_trees(const BRep & model)
```


### create_block_meshes_aabb_trees

```cpp
ModelMeshesAABBTree create_block_meshes_aabb_trees(const BRep & model)
```


### create_line_meshes_aabb_trees

```cpp
ModelMeshesAABBTree create_line_meshes_aabb_trees(const Section & model)
```


### create_surface_meshes_aabb_trees

```cpp
ModelMeshesAABBTree create_surface_meshes_aabb_trees(const Section & model)
```


### save_raster_image

```cpp
void save_raster_image(const RasterImage<dimension> & raster, string_view filename)
```


 API function for saving a RasterImage. The adequate saver is called depending on the given filename extension.

**raster** [in] RasterImage to save.

**filename** [in] Path to the file where save the RasterImage.

### merge_edged_curves

```cpp
int merge_edged_curves(absl::Span<const std::reference_wrapper<const EdgedCurve<dimension> > > curves)
```


### load_raster_image

```cpp
RasterImage<dimension> load_raster_image(string_view filename)
```


 API function for loading an RasterImage. The adequate loader is called depending on the filename extension. Default data structure implémentation is used.

**filename** [in] Path to the file to load.

### check_raster_image_missing_files

```cpp
typename RasterImageInput<dimension>::MissingFiles check_raster_image_missing_files(string_view filename)
```


### string_split

```cpp
vector string_split(string_view string)
```


### string_starts_with

```cpp
_Bool string_starts_with(string_view string, string_view check)
```


### string_to_index

```cpp
index_t string_to_index(string_view string)
```


### string_to_int

```cpp
int string_to_int(string_view string)
```


### string_to_float

```cpp
float string_to_float(string_view string)
```


### string_to_double

```cpp
double string_to_double(string_view string)
```


### file_exists

```cpp
_Bool file_exists(string_view file_path)
```


### check_keyword

```cpp
void check_keyword(std::ifstream & file, string_view keyword)
```


### line_starts_with

```cpp
_Bool line_starts_with(std::ifstream & file, string_view check)
```


### goto_keyword

```cpp
basic_string goto_keyword(std::ifstream & file, string_view word)
```


### goto_keywords

```cpp
basic_string goto_keywords(std::ifstream & file, Span words)
```


### goto_keyword_if_it_exists

```cpp
optional goto_keyword_if_it_exists(std::ifstream & file, string_view word)
```


### next_keyword_if_it_exists

```cpp
optional next_keyword_if_it_exists(std::ifstream & file, string_view word)
```




## Enums

| enum class Position |

--

| outside |
| inside |
| vertex0 |
| vertex1 |
| vertex2 |
| vertex3 |
| edge0 |
| edge1 |
| edge2 |
| edge01 |
| edge02 |
| edge03 |
| edge12 |
| edge13 |
| edge23 |
| facet0 |
| facet1 |
| facet2 |
| facet3 |
| parallel |



| enum class Side |

--

| positive |
| negative |
| zero |



| enum class IntersectionType |

--

| NONE |
| INTERSECT |
| PARALLEL |
| INCORRECT |





